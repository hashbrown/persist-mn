---
interface Props {
  categorySlug?: string;
  id?: string;
}

const { categorySlug, id = 'site-search' } = Astro.props;
---

<div
  class="relative w-full"
  data-search-root
  data-search-category={categorySlug ?? ''}
>
  <label class="sr-only" for={`${id}-input`}>Search businesses</label>
  <input
    id={`${id}-input`}
    type="search"
    inputmode="search"
    autocomplete="off"
    placeholder="Search businesses (name, city)"
    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm text-gray-900 shadow-sm placeholder:text-gray-400 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/30"
  />

  <div
    data-search-panel
    class="absolute left-0 right-0 z-30 mt-2 hidden overflow-hidden rounded-md border border-gray-200 bg-white shadow-lg"
  >
    <ul data-search-results class="max-h-80 overflow-auto"></ul>
  </div>
</div>

<script>
  import Fuse from 'fuse.js/basic'

  const MAX_RESULTS = 10
  const MIN_CHARS = 2
  const DEBOUNCE_MS = 200

  type SearchRecord = {
    id: string
    slug: string
    displayName: string
    city?: string
    state?: string
    category: string
    categorySlug: string
    description: string
  }

  type SearchCache = {
    indexPromise: Promise<SearchRecord[]> | null
    records: SearchRecord[] | null
    fuseByCategory: Map<string, Fuse<SearchRecord>>
  }

  type FuseResult = { item: SearchRecord }

  function debounce<T extends (...args: any[]) => void>(
    fn: T,
    ms: number
  ): (...args: Parameters<T>) => void {
    let t: number | undefined
    return (...args: Parameters<T>) => {
      if (t !== undefined) window.clearTimeout(t)
      t = window.setTimeout(() => fn(...args), ms)
    }
  }

  function getCache(): SearchCache {
    const key = '__persistmnSearchCache' as const
    const w = window as unknown as Record<string, unknown>
    if (!w[key]) {
      w[key] = {
        indexPromise: null,
        records: null,
        fuseByCategory: new Map<string, Fuse<SearchRecord>>(),
      } satisfies SearchCache
    }
    return w[key] as SearchCache
  }

  async function loadRecords(): Promise<SearchRecord[]> {
    const cache = getCache()
    if (cache.records) return cache.records

    if (!cache.indexPromise) {
      cache.indexPromise = fetch('/search-index.json', { credentials: 'same-origin' }).then(
        async (res) => {
          if (!res.ok) throw new Error(`Failed to load search index: ${res.status}`)
          return (await res.json()) as SearchRecord[]
        }
      )
    }

    cache.records = await cache.indexPromise
    return cache.records
  }

  function getFuseForCategory(records: SearchRecord[], categorySlug?: string): Fuse<SearchRecord> {
    const cache = getCache()
    const key = categorySlug || '*'
    const existing = cache.fuseByCategory.get(key)
    if (existing) return existing

    const dataset = categorySlug
      ? records.filter((r: SearchRecord) => r.categorySlug === categorySlug)
      : records

    const fuse = new Fuse<SearchRecord>(dataset, {
      includeScore: true,
      ignoreLocation: true,
      threshold: 0.3,
      minMatchCharLength: MIN_CHARS,
      keys: [
        { name: 'displayName', weight: 0.6 },
        { name: 'city', weight: 0.25 },
        { name: 'description', weight: 0.15 },
      ],
    })

    cache.fuseByCategory.set(key, fuse)
    return fuse
  }

  function openPanel(panelEl: HTMLElement) {
    panelEl.classList.remove('hidden')
  }

  function closePanel(panelEl: HTMLElement) {
    panelEl.classList.add('hidden')
  }

  function setResults(resultsEl: HTMLElement, itemsHtml: string) {
    resultsEl.innerHTML = itemsHtml
  }

  function escapeHtml(s: unknown): string {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;')
  }

  function renderMessage(resultsEl: HTMLElement, message: string) {
    setResults(
      resultsEl,
      `<li class="px-3 py-2 text-sm text-gray-500">${escapeHtml(message)}</li>`
    )
  }

  function renderResults(resultsEl: HTMLElement, results: FuseResult[]) {
    if (!results.length) {
      renderMessage(resultsEl, 'No matches')
      return
    }

    const html = results
      .slice(0, MAX_RESULTS)
      .map(({ item }) => {
        const name = escapeHtml(item.displayName)
        const cityState = escapeHtml(
          [item.city, item.state].filter(Boolean).join(', ')
        )
        const category = escapeHtml(item.category)
        const href = `/business/${item.slug}`

        return `
          <li>
            <a
              class="block px-3 py-2 hover:bg-blue-50 focus:bg-blue-50 focus:outline-none"
              href="${href}"
            >
              <div class="flex items-start justify-between gap-3">
                <div class="min-w-0">
                  <div class="truncate text-sm font-medium text-gray-900">${name}</div>
                  <div class="truncate text-xs text-gray-600">${cityState}</div>
                </div>
                <span class="shrink-0 rounded-full bg-blue-100 px-2 py-0.5 text-[11px] font-medium text-blue-800">
                  ${category}
                </span>
              </div>
            </a>
          </li>
        `
      })
      .join('')

    setResults(resultsEl, html)
  }

  function initSearchRoot(root: Element) {
    const categorySlug = root.getAttribute('data-search-category') || ''
    const input = root.querySelector('input[type="search"]') as HTMLInputElement | null
    const panel = root.querySelector('[data-search-panel]') as HTMLElement | null
    const resultsEl = root.querySelector('[data-search-results]') as HTMLUListElement | null

    if (!input || !panel || !resultsEl) return

    let lastQuery = ''

    const doSearch = debounce(async () => {
      const q = input.value.trim()
      lastQuery = q

      if (q.length < MIN_CHARS) {
        closePanel(panel)
        return
      }

      openPanel(panel)
      renderMessage(resultsEl, 'Searching…')

      try {
        const records = await loadRecords()
        // If the user kept typing while loading, ignore stale run.
        if (input.value.trim() !== lastQuery) return

        const fuse = getFuseForCategory(records, categorySlug || undefined)
        const results = fuse.search(q) as unknown as FuseResult[]
        renderResults(resultsEl, results)
      } catch (e) {
        renderMessage(resultsEl, 'Search unavailable')
        console.error(e)
      }
    }, DEBOUNCE_MS)

    input.addEventListener('input', doSearch)
    input.addEventListener('focus', () => {
      // Warm the cache on focus, but don’t force UI open.
      loadRecords().catch(() => {})
    })
    input.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        closePanel(panel)
        input.blur()
      }
    })

    document.addEventListener('click', (e: MouseEvent) => {
      const target = e.target
      if (!(target instanceof Node)) return
      if (!root.contains(target)) closePanel(panel)
    })
  }

  document.querySelectorAll('[data-search-root]').forEach((el) => initSearchRoot(el))
</script>

